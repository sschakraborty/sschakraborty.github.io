<html>
    <head>
        <title>Sorting Tutorials</title>
        <link rel="stylesheet" href="../../vendor/bootstrap/css/bootstrap.min.css" />
        <link rel="stylesheet" href="../../vendor/font-awesome/css/font-awesome.min.css" />
        <link rel="stylesheet" href="../../vendor/prism/prism.css" />
        
        <script type="text/javascript" src="../../vendor/jquery/jquery.min.js"></script>
        <script type="text/javascript" src="../../vendor/bootstrap/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="../../vendor/prism/prism.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-light bg-light bg-red border-dark border-bottom fixed-top">
            <a class="navbar-brand" href="#">Sorting</a>
            
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav mr-auto border border-dark rounded text-center" style="margin: 25px !important; padding: 25px !important;">
                    <li class="nav-item"><a class="nav-link" href="#">Website Main Page</a></li>
                    <li class="nav-item"><a class="nav-link" href="#">Tutorials Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="#">Sorting Theory &amp; Introduction</a></li>
                    <li class="nav-item"><a class="nav-link" href="#">Python 3 Implementations</a></li>
                </ul>
            </div>
        </nav>
        
        <div class="container" style="margin-top: 70px !important;">
            <h2>Theory of Sorting</h2>
            <br>
            In computer science, arranging in an ordered sequence is called "sorting". Sorting is a common operation in many applications, and efficient algorithms to perform it have been developed.
            <br>
            The most common uses of sorted sequences are:
            <br>
            <ul>
                <li>Making lookup or search efficient.</li>
                <li>Making merging of sequences efficient.</li>
                <li>Enable processing of data in a defined order.</li>
            </ul>

            The opposite of sorting, rearranging a sequence of items in a random or meaningless order, is called shuffling.
            <br><br>

            For sorting, either a weak order, "should not come after", can be specified, or a strict weak order, "should come before" (specifying one defines also the other, the two are the complement of the inverse of each other, see operations on binary relations). For the sorting to be unique, these two are restricted to a total order and a strict total order, respectively.
            <br><br>

            Sorting n-tuples (depending on context also called e.g. records consisting of fields) can be done based on one or more of its components. More generally objects can be sorted based on a property. Such a component or property is called a sort key.
            <br><br>

            For example, the items are books, the sort key is the title, subject or author, and the order is alphabetical.
            <br><br>

            A new sort key can be created from two or more sort keys by lexicographical order. The first is then called the primary sort key, the second the secondary sort key, etc.
            <br><br>

            For example, addresses could be sorted using the city as primary sort key, and the street as secondary sort key.
            <br><br>

            If the sort key values are totally ordered, the sort key defines a weak order of the items: items with the same sort key are equivalent with respect to sorting. See also stable sorting. If different items have different sort key values then this defines a unique order of the items.
            <br><br>

            Workers sorting parcels in a postal facility
            <br><br>

            A standard order is often called ascending (corresponding to the fact that the standard order of numbers is ascending, i.e. A to Z, 0 to 9), the reverse order descending (Z to A, 9 to 0). For dates and times, ascending means that earlier values precede later ones e.g. 1/1/2000 will sort ahead of 1/1/2001.
        </div>
        
        <div class="container" style="margin-top: 70px !important;">
            <h2>Selection Sort</h2>
            <h3>(Comparison sort of &theta;(N<sup>2</sup>) complexity)</h3>
            <br>
            
            <pre class="lang-python"><code># Selection sort implementation in Python 3

from random import random as r

array = [int(r() * 1024) for i in range(16)]


def sort():
    for i in range(len(array)):
        min_value = array[i]
        min_pos = i
        for j in range(i + 1, len(array)):
            if array[j] < min_value:
                min_value = array[j]
                min_pos = j
        # Swap array[i] with array[min_pos]
        array[i], array[min_pos] = array[min_pos], array[i]


if __name__ == "__main__":
    print("Unsorted Array: ", array)
    sort()
    print("Sorted Array: ", array)</code></pre>
        </div>
        
        
        <div class="container" style="margin-top: 70px !important;">
            <h2>Bubble Sort</h2>
            <h3>(Comparison sort of &theta;(N<sup>2</sup>) complexity)</h3>
            <br>
            
            <pre class="lang-python"><code># Bubble Sort implementation in Python 3

from random import random as r

array = [int(r() * 1024) for i in range(16)]


def sort():
    for i in range(len(array)):
        for j in range(len(array) - i - 1):
            if array[j] > array[j + 1]:
                array[j], array[j + 1] = array[j + 1], array[j]


if __name__ == "__main__":
    print("Unsorted Array: ", array)
    sort()
    print("Sorted Array: ", array)</code></pre>
        </div>
        
        
        <div class="container" style="margin-top: 70px !important;">
            <h2>Quick Sort</h2>
            <h3>(Comparison sort of <code>&theta;(N log<sub>2</sub> N)</code> average-case complexity</h3>
            <h3>Has <code>&theta;(N<sup>2</sup>)</code> worst-case complexity)</h3>
            <br>
            
            <pre class="lang-python"><code># Quick Sort implementation in Python 3

from random import random as r

array = [int(r() * 1024) for i in range(16)]


# Lomuto Partition function
def partition(lb, ub):
    pivot_index = ub
    k = lb - 1
    for i in range(lb, ub):
        if array[i] < array[pivot_index]:
            k += 1
            array[k], array[i] = array[i], array[k]
    k += 1
    array[k], array[pivot_index] = array[pivot_index], array[k]
    return k


# Quick Sort recursive implementation
def quick_sort(lb, ub):
    if lb < ub:
        p = partition(lb, ub)
        quick_sort(lb, p - 1)
        quick_sort(p + 1, ub)


# Quick Sort implementation
def sort():
    quick_sort(0, len(array) - 1)


if __name__ == "__main__":
    print("Unsorted Array: ", array)
    sort()
    print("Sorted Array: ", array)</code></pre>
        </div>
        
        
        <div class="container" style="margin-top: 70px !important;">
            <h2>Heap Sort</h2>
            <h3>(Unstable comparison sort of <code>&theta;(N log<sub>2</sub> N)</code> complexity)</h3>
            <br>
            
            <pre class="lang-python"><code># Heap Sort implementation in Python 3

from random import random as r

array = [int(r() * 1024) for i in range(16)]


def parent(index):
    return (index - 1) >> 1


def right(index):
    return (index << 1) + 1


def left(index):
    return (index << 1) + 2


# Function to build max heap from given array
def build_max_heap():
    for i in range(len(array)):
        index = i
        while parent(index) >= 0 and array[index] > array[parent(index)]:
            array[index], array[parent(index)] = array[parent(index)], array[index]
            index = parent(index)


# Iterative Heap Sort implementation
def sort():
    build_max_heap()
    size = len(array)
    for i in range(len(array)):
        array[0], array[size - 1] = array[size - 1], array[0]
        size -= 1
        # Swim down the top of heap until balanced
        current_index = 0
        while True:
            max_index = current_index
            if left(current_index) < size and array[left(current_index)] > array[max_index]:
                max_index = left(current_index)
            if right(current_index) < size and array[right(current_index)] > array[max_index]:
                max_index = right(current_index)
            if max_index != current_index:
                array[max_index], array[current_index] = array[current_index], array[max_index]
                current_index = max_index
            else:
                break


if __name__ == "__main__":
    print("Unsorted Array: ", array)
    build_max_heap()
    print("Max Heap: ", array)
    sort()
    print("Sorted Array: ", array)</code></pre>
        </div>
        
        
    </body>
</html>
